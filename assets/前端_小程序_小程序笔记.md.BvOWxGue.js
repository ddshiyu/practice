import{_ as a,c as s,o as n,aq as e}from"./chunks/framework.ATjo20Wq.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端/小程序/小程序笔记.md","filePath":"前端/小程序/小程序笔记.md","lastUpdated":1745042540000}'),t={name:"前端/小程序/小程序笔记.md"},p=e(`<h3 id="_1-swiper圆角真机上不显示" tabindex="-1">1. swiper圆角真机上不显示 <a class="header-anchor" href="#_1-swiper圆角真机上不显示" aria-label="Permalink to &quot;1. swiper圆角真机上不显示&quot;">​</a></h3><blockquote><p><strong>小程序bug</strong>，居然还没修复，在css设置如下</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>.swiper{ width: 100%; height: 100%; border-radius: 20rpx; overflow: hidden; transform: translateY(0);</span></span></code></pre></div><h3 id="_2-input去除阴影" tabindex="-1">2. input去除阴影 <a class="header-anchor" href="#_2-input去除阴影" aria-label="Permalink to &quot;2. input去除阴影&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>input{</span></span>
<span class="line"><span>    border:none;</span></span>
<span class="line"><span>    -webkit-appearance:none;/*去除阴影边框*/</span></span>
<span class="line"><span>    outline: none;</span></span>
<span class="line"><span>    -webkit-tap-highlight-color:rgba(0,0,0,0);/*点击高亮的颜色*/</span></span>
<span class="line"><span> }</span></span></code></pre></div><h3 id="tinymce表单编辑" tabindex="-1">tinymce表单编辑 <a class="header-anchor" href="#tinymce表单编辑" aria-label="Permalink to &quot;tinymce表单编辑&quot;">​</a></h3><p>需要加上v-if，否则可能出不来</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>&lt;tinymce v-if=&quot;dialogFormVisible1&quot; ref=&quot;cleanArticle&quot; v-model=&quot;formProduct.topNav2&quot; /&gt;</span></span></code></pre></div><h3 id="在页面中使用-behaviors" tabindex="-1">在页面中使用 behaviors <a class="header-anchor" href="#在页面中使用-behaviors" aria-label="Permalink to &quot;在页面中使用 behaviors&quot;">​</a></h3><p>页面可以引用 behaviors 。 behaviors 可以用来让多个页面有相同的数据字段和方法。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// my-behavior.js</span></span>
<span class="line"><span>module.exports = Behavior({</span></span>
<span class="line"><span>  data: {</span></span>
<span class="line"><span>    sharedText: &#39;This is a piece of data shared between pages.&#39;</span></span>
<span class="line"><span>  },</span></span>
<span class="line"><span>  methods: {</span></span>
<span class="line"><span>    sharedMethod: function() {</span></span>
<span class="line"><span>      this.data.sharedText === &#39;This is a piece of data shared between pages.&#39;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }})</span></span>
<span class="line"><span>// page-a.js</span></span>
<span class="line"><span>var myBehavior = require(&#39;./my-behavior.js&#39;)Page({</span></span>
<span class="line"><span>  behaviors: [myBehavior],</span></span>
<span class="line"><span>  onLoad: function() {</span></span>
<span class="line"><span>    this.data.sharedText === &#39;This is a piece of data shared between pages.&#39;</span></span>
<span class="line"><span>  }})</span></span></code></pre></div><ul><li>可以使用 getCurrentPages() 函数获取当前页面栈</li></ul><h3 id="路由方式" tabindex="-1">路由方式 <a class="header-anchor" href="#路由方式" aria-label="Permalink to &quot;路由方式&quot;">​</a></h3><ol><li>打开新页面  wx.navigateTo 或者</li><li>页面重定向 wx.redirectTo</li><li>页面返回 wx.navigateBack</li><li>Tab 切换 wx.switchTab</li><li>重启动 wx.reLaunch</li></ol><p>navigateTo, redirectTo 只能打开非 tabBar 页面。switchTab 只能打开 tabBar 页面。reLaunch 可以打开任意页面。页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。调用页面路由带的参数可以在目标页面的onLoad中获取。</p><h3 id="异步方式" tabindex="-1">异步方式 <a class="header-anchor" href="#异步方式" aria-label="Permalink to &quot;异步方式&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// callback 形式调用</span></span>
<span class="line"><span>wx.chooseImage({</span></span>
<span class="line"><span>  success(res) {</span></span>
<span class="line"><span>    console.log(&#39;res:&#39;, res)</span></span>
<span class="line"><span>  }})</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// promise 形式调用</span></span>
<span class="line"><span>wx.chooseImage().then(res =&gt; console.log(&#39;res: &#39;, res))</span></span></code></pre></div><h3 id="rpx" tabindex="-1">rpx <a class="header-anchor" href="#rpx" aria-label="Permalink to &quot;rpx&quot;">​</a></h3><p>rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</p><h3 id="wxs" tabindex="-1">wxs <a class="header-anchor" href="#wxs" aria-label="Permalink to &quot;wxs&quot;">​</a></h3><p>WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构 和wxml放在一起</p><h3 id="事件" tabindex="-1">事件 <a class="header-anchor" href="#事件" aria-label="Permalink to &quot;事件&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>&lt;view id=&quot;tapTest&quot; data-hi=&quot;Weixin&quot; bindtap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt;</span></span></code></pre></div><p>data-hi可以在事件对象e中打印出来</p><ul><li>除 bind 外，也可以用 catch 来绑定事件。与 bind 不同， catch 会阻止事件向上冒泡</li><li>在捕获阶段监听事件时可以采用capture-bind、capture-catch关键字，后者将中断捕获阶段和取消冒泡阶段。</li><li>mark和dataset相似</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>&lt;view mark:myMark=&quot;last&quot; bindtap=&quot;bindViewTap&quot;&gt;</span></span>
<span class="line"><span>  &lt;button mark:anotherMark=&quot;leaf&quot; bindtap=&quot;bindButtonTap&quot;&gt;按钮&lt;/button&gt;</span></span>
<span class="line"><span>&lt;/view&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>点击按钮</span></span>
<span class="line"><span>Page({</span></span>
<span class="line"><span>  bindViewTap: function(e) {</span></span>
<span class="line"><span>    e.mark.myMark === &quot;last&quot; // true</span></span>
<span class="line"><span>    e.mark.anotherMark === &quot;leaf&quot; // true</span></span>
<span class="line"><span>  }})</span></span></code></pre></div><h4 id="互斥事件绑定" tabindex="-1">互斥事件绑定 <a class="header-anchor" href="#互斥事件绑定" aria-label="Permalink to &quot;互斥事件绑定&quot;">​</a></h4><p>除 bind 和 catch 外，还可以使用 mut-bind 来绑定事件。一个 mut-bind 触发后，如果事件冒泡到其他节点上，其他节点上的 mut-bind 绑定函数不会被触发，但 bind 绑定函数和 catch 绑定函数依旧会被触发。换而言之，所有 mut-bind 是“互斥”的，只会有其中一个绑定函数被触发。同时，它完全不影响 bind 和 catch 的绑定效果。</p><h3 id="滚动动画" tabindex="-1">滚动动画 <a class="header-anchor" href="#滚动动画" aria-label="Permalink to &quot;滚动动画&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>this.animate(selector, keyframes, duration, ScrollTimeline)</span></span></code></pre></div><h3 id="静态初始渲染缓存" tabindex="-1">静态初始渲染缓存 <a class="header-anchor" href="#静态初始渲染缓存" aria-label="Permalink to &quot;静态初始渲染缓存&quot;">​</a></h3><ul><li>若想启用初始渲染缓存，最简单的方法是在页面的 json 文件中添加配置项 &quot;initialRenderingCache&quot;: &quot;static&quot;</li><li>静态缓存不能使用this.setData改变数据，这种做法只包含页面 data 的渲染结果，即页面的纯静态成分</li></ul><h3 id="组件" tabindex="-1">组件 <a class="header-anchor" href="#组件" aria-label="Permalink to &quot;组件&quot;">​</a></h3><ul><li>在组件wxss中不应使用ID选择器、属性选择器和标签名选择器</li><li>使用已注册的自定义组件前，首先要在页面的 json 文件中进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径</li><li>默认情况下，一个组件的 wxml 中只能有一个 slot 。需要使用多 slot 时，可以在组件 js 中声明启用。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>options: {</span></span>
<span class="line"><span>    multipleSlots: true // 在组件定义时的选项中启用多slot支持</span></span>
<span class="line"><span>  },</span></span></code></pre></div><ul><li>自定义组件设置为“虚拟的”,将不受 页面css的影响</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>options: {</span></span>
<span class="line"><span>    virtualHost: true</span></span>
<span class="line"><span>  },</span></span></code></pre></div><ul><li>页面也可以使用 Component 构造器构造，应 json 文件中包含 usingComponents 定义段。组件的属性可以用于接收页面的参数，页面的生命周期方法（即 on 开头的方法），应写在 methods 定义段中。</li><li>this.selectComponent 获取自组件实例，好玩vue的$refs类似</li><li>子组件触发事件</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>this.triggerEvent(&#39;myevent&#39;, myEventDetaildetail(对象，提供给事件监听函数), myEventOption(触发的选项))</span></span></code></pre></div><ul><li>自定义 selectComponent 返回的数据，可使用内置 behavior: wx://component-export，使自定义组件中支持 export 定义段，这个定义段可以用于指定组件被 selectComponent 调用时的返回值。</li><li>使用behavior之后，生命周期函数，先调用behavior中的函数</li><li>behavior覆盖原则</li></ul><ol><li>如果若组件本身有这个属性或方法，则组件的属性或方法会覆盖 behavior 中的同名属性或方法；</li><li>若组件本身无这个属性或方法，则在组件的 behaviors 字段中定义靠后的 behavior 的属性或方法会覆盖靠前的同名属性或方法；</li><li>在 2 的基础上，若存在嵌套引用 behavior 的情况，则规则为：父 behavior 覆盖 子 behavior 中的同名属性或方法。</li></ol><ul><li>定义和组件间的关系，在构造器中加入relations属性</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>&lt;custom-ul&gt;</span></span>
<span class="line"><span>  &lt;custom-li&gt; item 1 &lt;/custom-li&gt;</span></span>
<span class="line"><span>  &lt;custom-li&gt; item 2 &lt;/custom-li&gt;</span></span>
<span class="line"><span>&lt;/custom-ul&gt;</span></span></code></pre></div><ul><li>observers可以监听数据变化，类似于watch</li><li>组件数据中的纯数据字段,既不会展示在界面上，也不会传递给其他组件</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>options: {</span></span>
<span class="line"><span>    pureDataPattern: /^_/ // 指定所有 _ 开头的数据字段为纯数据字段</span></span>
<span class="line"><span>  },</span></span></code></pre></div><h4 id="_1、访问失败fail未执行" tabindex="-1">1、访问失败fail未执行 <a class="header-anchor" href="#_1、访问失败fail未执行" aria-label="Permalink to &quot;1、访问失败fail未执行&quot;">​</a></h4><ul><li>fail监听的网络，网络请求正常不会被fail监听，只有网络出错（接口未打开或者没网）</li><li>接口服务正常，接口请求出错会被success监听</li></ul><h3 id="getcurrentpages" tabindex="-1">getCurrentPages <a class="header-anchor" href="#getcurrentpages" aria-label="Permalink to &quot;getCurrentPages&quot;">​</a></h3><ul><li>getcurrpage 会获得一个页面堆栈 当页面堆栈数量==1的时候，按钮改成返回首页</li></ul><h3 id="互斥事件绑定-1" tabindex="-1">互斥事件绑定 <a class="header-anchor" href="#互斥事件绑定-1" aria-label="Permalink to &quot;互斥事件绑定&quot;">​</a></h3><p>使用mut-bind来绑定事件，当深层的mut-bind事件点击后冒泡到上层，如果碰到仍然是mut-bind，则该事件不会执行</p><h3 id="页面路由" tabindex="-1">页面路由 <a class="header-anchor" href="#页面路由" aria-label="Permalink to &quot;页面路由&quot;">​</a></h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route.html" target="_blank" rel="noreferrer">链接</a></p><h3 id="异步api" tabindex="-1">异步api <a class="header-anchor" href="#异步api" aria-label="Permalink to &quot;异步api&quot;">​</a></h3><p>异步api支持callback 和 promise两种调用方式</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// callback 形式调用</span></span>
<span class="line"><span>wx.chooseImage({</span></span>
<span class="line"><span>  success(res) {</span></span>
<span class="line"><span>    console.log(&#39;res:&#39;, res)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// promise 形式调用</span></span>
<span class="line"><span>wx.chooseImage().then(res =&gt; console.log(&#39;res: &#39;, res))</span></span></code></pre></div><h3 id="双向绑定" tabindex="-1">双向绑定 <a class="header-anchor" href="#双向绑定" aria-label="Permalink to &quot;双向绑定&quot;">​</a></h3><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/two-way-bindings.html" target="_blank" rel="noreferrer">链接</a></li></ul><h3 id="节点相交" tabindex="-1">节点相交 <a class="header-anchor" href="#节点相交" aria-label="Permalink to &quot;节点相交&quot;">​</a></h3><ul><li>在每次进入或者离开下时调用回调 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/selector.html" target="_blank" rel="noreferrer">链接</a></li></ul><h3 id="动画" tabindex="-1">动画 <a class="header-anchor" href="#动画" aria-label="Permalink to &quot;动画&quot;">​</a></h3><ul><li>使用css动画，用bindtransitionend、bindanimationstart、bindanimationiteration、bindanimationend来监听动画</li><li>使用关键帧动画<code>this.animate(selector, keyframes, duration, callback)</code></li><li>滚动动画<code>this.animate(selector, keyframes, duration, ScrollTimeline)</code></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/animation.html" target="_blank" rel="noreferrer">链接</a></li></ul><h3 id="小程序的运行环境" tabindex="-1">小程序的运行环境 <a class="header-anchor" href="#小程序的运行环境" aria-label="Permalink to &quot;小程序的运行环境&quot;">​</a></h3><table><thead><tr><th></th><th>ios</th><th>Android</th><th>开发工具</th><th>pc</th><th>mac</th></tr></thead><tbody><tr><td>js</td><td>JavaScriptCore</td><td>v8</td><td>NW.js</td><td>Chrome</td><td>JavaScriptCore</td></tr><tr><td>视图</td><td>WKWebView</td><td>XWeb</td><td>Chromium Webview</td><td>Chrome</td><td>WKWebView</td></tr></tbody></table><h3 id="小程序销毁之前保留数据" tabindex="-1">小程序销毁之前保留数据 <a class="header-anchor" href="#小程序销毁之前保留数据" aria-label="Permalink to &quot;小程序销毁之前保留数据&quot;">​</a></h3><p>每当小程序可能被销毁之前，页面回调函数 onSaveExitState 会被调用。如果想保留页面中的状态，可以在这个回调函数中“保存”一些数据，下次启动时可以通过 exitState 获得这些已保存数据。<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/operating-mechanism.html" target="_blank" rel="noreferrer">链接</a></p><h3 id="小程序生成二维码" tabindex="-1">小程序生成二维码 <a class="header-anchor" href="#小程序生成二维码" aria-label="Permalink to &quot;小程序生成二维码&quot;">​</a></h3><p><a href="https://open.weixin.qq.com/sns/getexpappinfo?appid=" target="_blank" rel="noreferrer">https://open.weixin.qq.com/sns/getexpappinfo?appid=</a>&amp;path=***</p><h3 id="小程序初始渲染" tabindex="-1">小程序初始渲染 <a class="header-anchor" href="#小程序初始渲染" aria-label="Permalink to &quot;小程序初始渲染&quot;">​</a></h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/initial-rendering-cache.html" target="_blank" rel="noreferrer">链接</a> 很重要，一般是静态渲染，不包含setData的数据，需要再app.json中添加</p><h3 id="生成小程序" tabindex="-1">生成小程序 <a class="header-anchor" href="#生成小程序" aria-label="Permalink to &quot;生成小程序&quot;">​</a></h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.createQRCode.html" target="_blank" rel="noreferrer">链接</a></p><h3 id="自定义组件" tabindex="-1">自定义组件 <a class="header-anchor" href="#自定义组件" aria-label="Permalink to &quot;自定义组件&quot;">​</a></h3><p>在json文件中加入</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>{</span></span>
<span class="line"><span>  &quot;component&quot;: true</span></span>
<span class="line"><span> }</span></span></code></pre></div><blockquote><p><strong>在组件wxss中不应使用ID选择器、属性选择器和标签名选择器。</strong></p></blockquote><p>wxml可以使用多个slo，要在js中配置</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>options: {</span></span>
<span class="line"><span>    multipleSlots: true // 在组件定义时的选项中启用多slot支持</span></span>
<span class="line"><span>  },</span></span></code></pre></div><p>然后slot用name来区分</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>模板组件</span></span>
<span class="line"><span>&lt;slot name=&quot;before&quot;&gt;&lt;/slot&gt;</span></span>
<span class="line"><span> 引用组件的页面模板</span></span>
<span class="line"><span>&lt;view slot=&quot;before&quot;&gt;这里是插入到组件slot name=&quot;before&quot;中的内容&lt;/view&gt;</span></span></code></pre></div><h4 id="样式隔离" tabindex="-1">样式隔离 <a class="header-anchor" href="#样式隔离" aria-label="Permalink to &quot;样式隔离&quot;">​</a></h4><p>通常页面指定了标签选择器才会影响组件的样式，所以不推荐使用标签选择器</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>options: {</span></span>
<span class="line"><span>    styleIsolation: &#39;isolated&#39;</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span> 或者</span></span>
<span class="line"><span>options: {</span></span>
<span class="line"><span>    addGlobalClass: true,</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span>或者  .json</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  &quot;styleIsolation&quot;: &quot;isolated&quot;</span></span>
<span class="line"><span> }</span></span></code></pre></div><ul><li>isolated 表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响（一般情况下的默认值）；</li><li>apply-shared 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面；</li><li>shared 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 apply-shared 或 shared 的自定义组件。（这个选项在插件中不可用。）</li></ul><h4 id="接受传入的样式" tabindex="-1">接受传入的样式 <a class="header-anchor" href="#接受传入的样式" aria-label="Permalink to &quot;接受传入的样式&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>/* 组件 custom-component.js */</span></span>
<span class="line"><span>externalClasses: [&#39;my-class&#39;]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;view class=&quot;my-class&quot;&gt;这段文本的颜色由组件外的 class 决定&lt;/view&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;!-- 页面的 WXML --&gt;</span></span>
<span class="line"><span>&lt;custom-component my-class=&quot;red-text&quot; /&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.red-text {</span></span>
<span class="line"><span>  color: red;</span></span>
<span class="line"><span> }</span></span></code></pre></div><h4 id="引用页面或父组件的样式" tabindex="-1">引用页面或父组件的样式 <a class="header-anchor" href="#引用页面或父组件的样式" aria-label="Permalink to &quot;引用页面或父组件的样式&quot;">​</a></h4><ul><li><code>~</code> + 类名，即可引用页面的样式</li><li><code>^</code> + 类名，即可引用父组件的样式</li></ul><h4 id="虚拟化组件节点" tabindex="-1">虚拟化组件节点 <a class="header-anchor" href="#虚拟化组件节点" aria-label="Permalink to &quot;虚拟化组件节点&quot;">​</a></h4><p>组件添加这个属性，则不能在节点上使用style，class等属性</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>options: {</span></span>
<span class="line"><span>    virtualHost: true</span></span>
<span class="line"><span>  },</span></span>
<span class="line"><span> 以下不生效</span></span>
<span class="line"><span>&lt;custom-component style=&quot;color: blue; flex: 1&quot;&gt;蓝色、满宽的&lt;/custom-component&gt;</span></span></code></pre></div><h4 id="component-构造页面" tabindex="-1">Component 构造页面 <a class="header-anchor" href="#component-构造页面" aria-label="Permalink to &quot;Component 构造页面&quot;">​</a></h4><ul><li>把on事件写在methods中</li><li>好处是可以使用behaviors</li></ul><h4 id="获取组件实例" tabindex="-1">获取组件实例 <a class="header-anchor" href="#获取组件实例" aria-label="Permalink to &quot;获取组件实例&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>this.selectComponent(&quot;.my-component&quot;)</span></span></code></pre></div><h4 id="数据监听" tabindex="-1">数据监听 <a class="header-anchor" href="#数据监听" aria-label="Permalink to &quot;数据监听&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>observers: {</span></span>
<span class="line"><span>    &#39;**&#39;: function() {</span></span>
<span class="line"><span>      // 每次 setData 都触发</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>  },</span></span></code></pre></div><p>监听对象的属性，在对象改变时也会触发</p><h4 id="纯数据字段" tabindex="-1">纯数据字段 <a class="header-anchor" href="#纯数据字段" aria-label="Permalink to &quot;纯数据字段&quot;">​</a></h4><p>只在js中使用，没有渲染到wxml中，在data中定义，</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>options: {</span></span>
<span class="line"><span>    pureDataPattern: /^_/ // 指定所有 _ 开头的数据字段为纯数据字段</span></span>
<span class="line"><span> },</span></span></code></pre></div><h4 id="抽象节点" tabindex="-1">抽象节点 <a class="header-anchor" href="#抽象节点" aria-label="Permalink to &quot;抽象节点&quot;">​</a></h4><p>使用一套抽象节点，可以定义多套组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/generics.html" target="_blank" rel="noreferrer">链接</a></p><h3 id="按需注入" tabindex="-1">按需注入 <a class="header-anchor" href="#按需注入" aria-label="Permalink to &quot;按需注入&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>{</span></span>
<span class="line"><span>  &quot;lazyCodeLoading&quot;: &quot;requiredComponents&quot;</span></span>
<span class="line"><span> }</span></span></code></pre></div><h3 id="授权" tabindex="-1">授权 <a class="header-anchor" href="#授权" aria-label="Permalink to &quot;授权&quot;">​</a></h3><ul><li>通过wx.getSetting获取当钱用户的授权状态</li><li>通过wx.openSetting打开设置界面，引导开启授权</li><li>使用wx.authorize获取授权</li></ul><h3 id="获取手机号" tabindex="-1">获取手机号 <a class="header-anchor" href="#获取手机号" aria-label="Permalink to &quot;获取手机号&quot;">​</a></h3><p>需要把获取到的“encryptedData”，“iv”传到后端，在使用session_key来解密，<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html" target="_blank" rel="noreferrer">链接</a></p><h3 id="获取小程序码" tabindex="-1">获取小程序码 <a class="header-anchor" href="#获取小程序码" aria-label="Permalink to &quot;获取小程序码&quot;">​</a></h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/qr-code.html" target="_blank" rel="noreferrer">链接</a></p><h3 id="获取-url-scheme" tabindex="-1">获取 URL Scheme <a class="header-anchor" href="#获取-url-scheme" aria-label="Permalink to &quot;获取 URL Scheme&quot;">​</a></h3><ul><li>适用于从短信、邮件、微信外网页等场景打开小程序 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/url-scheme.html" target="_blank" rel="noreferrer">链接</a></li></ul><h3 id="window-page" tabindex="-1">window/page <a class="header-anchor" href="#window-page" aria-label="Permalink to &quot;window/page&quot;">​</a></h3><p>enablePullDownRefresh: 开启下拉刷新 onReachBottomDistance: 页面上拉触底事件触发时距页面底部距离，单位为 px</p><h3 id="弹窗组件" tabindex="-1">弹窗组件 <a class="header-anchor" href="#弹窗组件" aria-label="Permalink to &quot;弹窗组件&quot;">​</a></h3><p>page-container</p><h3 id="页面穿梭动画组件" tabindex="-1">页面穿梭动画组件 <a class="header-anchor" href="#页面穿梭动画组件" aria-label="Permalink to &quot;页面穿梭动画组件&quot;">​</a></h3><p>share-element</p><h3 id="默认图标" tabindex="-1">默认图标 <a class="header-anchor" href="#默认图标" aria-label="Permalink to &quot;默认图标&quot;">​</a></h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/icon.html#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81" target="_blank" rel="noreferrer">链接</a></p><h3 id="富文本编辑器" tabindex="-1">富文本编辑器 <a class="header-anchor" href="#富文本编辑器" aria-label="Permalink to &quot;富文本编辑器&quot;">​</a></h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/editor.html#Bug-Tip" target="_blank" rel="noreferrer">链接</a></p><h3 id="跳转" tabindex="-1">跳转 <a class="header-anchor" href="#跳转" aria-label="Permalink to &quot;跳转&quot;">​</a></h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html#Bug-Tip" target="_blank" rel="noreferrer">链接</a></p><h3 id="开放头像和昵称" tabindex="-1">开放头像和昵称 <a class="header-anchor" href="#开放头像和昵称" aria-label="Permalink to &quot;开放头像和昵称&quot;">​</a></h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81" target="_blank" rel="noreferrer">链接</a></p><h3 id="网页" tabindex="-1">网页 <a class="header-anchor" href="#网页" aria-label="Permalink to &quot;网页&quot;">​</a></h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html" target="_blank" rel="noreferrer">网页</a></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>bindGetUserInfo({currentTarget = {}}) {</span></span>
<span class="line"><span>    debugger</span></span>
<span class="line"><span>    store.dispatch({type: &quot;SET_tappedUserAuth&quot;, data: true})</span></span>
<span class="line"><span>    // let id = store.getData().userid</span></span>
<span class="line"><span>    let token = store.getData().token;</span></span>
<span class="line"><span>    console.log(token, &#39;token用户授权&#39;)</span></span>
<span class="line"><span>    // console.log(id,&#39;id用户授权&#39;)</span></span>
<span class="line"><span>    let {type = &#39;&#39;} = currentTarget.dataset</span></span>
<span class="line"><span>    wx.getSetting({</span></span>
<span class="line"><span>      success: (res) =&gt; {</span></span>
<span class="line"><span>        if (res.authSetting[&#39;scope.userInfo&#39;]) {</span></span>
<span class="line"><span>          // 已经授权，可以直接调用 getUserInfo 获取头像昵称</span></span>
<span class="line"><span>          wx.getUserInfo({</span></span>
<span class="line"><span>            success: (res) =&gt; {</span></span>
<span class="line"><span>              let encryptedData = res.encryptedData</span></span>
<span class="line"><span>              let iv = res.iv</span></span>
<span class="line"><span>              User.getUserInfo({encryptedData, iv}).then(userInfo =&gt; {</span></span>
<span class="line"><span>                let unionId = userInfo.unionId;</span></span>
<span class="line"><span>                store.dispatch({type: &quot;SET_UNIONID&quot;, data: unionId})</span></span>
<span class="line"><span>                this.setData({ // 将获取到的unionId存起来，然后刷新globalData</span></span>
<span class="line"><span>                  globalData: store.getData(),</span></span>
<span class="line"><span>                })</span></span>
<span class="line"><span>              })</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>          })</span></span>
<span class="line"><span>        } else {</span></span>
<span class="line"><span>          console.log(&#39;用户拒绝授权&#39;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>          if (store.getData().phone) { // 刷新以后再去判断是否有phone，如果没有，再次弹窗让用户授权手机号</span></span>
<span class="line"><span>            this.setData({</span></span>
<span class="line"><span>              globalData: store.getData()</span></span>
<span class="line"><span>            })</span></span>
<span class="line"><span>          } else {</span></span>
<span class="line"><span>            this.setData({</span></span>
<span class="line"><span>              globalData: store.getData()</span></span>
<span class="line"><span>            })</span></span>
<span class="line"><span>          }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>  },</span></span></code></pre></div>`,130),l=[p];function i(o,r,c,h,d,u){return n(),s("div",null,l)}const g=a(t,[["render",i]]);export{m as __pageData,g as default};
